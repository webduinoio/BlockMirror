<!DOCTYPE html>
<html>

<head>
    <title>Draggable Divs</title>
    <style>
        .box {
            position: relative;
            width: 200px;
            height: 200px;
            border: 1px solid;
        }

        .dragDiv {
            position: relative;
            width: 200px;
            height: 200px;
        }

        .title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ccc;
            cursor: move;
            display: none;
            z-index: 2;
            opacity: 0.5;
        }

        #startButton,
        #stopButton {
            margin-top: 20px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <button id="startButton">Start</button>
    <button id="stopButton">Stop</button>
    <div>
        <div id="box1" class="box">
            box1
            <div id="dd1" class="dragDiv">
                <h1><span style='font-size:164px'>1</span></h1>
            </div>
        </div>
        <div id="box2" class="box">
            box2
            <div id="dd2" class="dragDiv">
                <h1><span style='font-size:164px'>2</span></h1>
            </div>
        </div>

        <div id="box3" class="box">
            box3
        </div>
    </div>
    <script>

        /**
         * 將想要可拖拉的div套上class="box"
         * 
         */
        class Box {
            // 所有可拖拉的盒子
            static boxes = [];
            static boxesInitPos = {};

            static addBox(box) {
                Box.boxes.push(box);
                // 元素擺放到畫面時的左上角 x,y 座標 (尚未拖拉前的位置)
                Box.boxesInitPos[box.getBox().id] = {
                    "x": box.getBox().offsetLeft,
                    "y": box.getBox().offsetTop
                }
                window[box.getBox().id] = box;
            }

            static getBoxes() {
                return Box.boxes;
            }

            static saveTmpLeftTop(box) {
                var left = box.getBox().style.left;
                var top = box.getBox().style.top;
                box.tmp = {
                    left: left == '' ? '0px' : left,
                    top: top == '' ? 'opx' : top
                }
            }

            static loadTmpLeftTop(box) {
                box.getBox().style.left = box.tmp.left;
                box.getBox().style.top = box.tmp.top;
                delete box.tmp;
            }

            static updateLeftTop(box, dx, dy) {
                var x = box.getBox().style.left;
                var y = box.getBox().style.top;
                x = parseInt(x.replace('px', '')) + dx;
                y = parseInt(y.replace('px', '')) + dy;
                box.getBox().style.left = x + "px";
                box.getBox().style.top = y + "px";
            }

            constructor(boxId) {
                this.swapPos = false;
                this.isDragging = false;
                this.eleTitle = document.createElement('div');
                this.eleTitle.classList.add("title");
                this.eleBox = document.getElementById(boxId);
                this.eleBox.appendChild(this.eleTitle);
                this.container = document.getElementsByTagName('body')[0];
                this.eleBox.style.top = '0px';
                this.eleBox.style.left = '0px';
            }

            startDrag() {
                var self = this;
                this.getTitle().style.display = "block";

                // mousedown event
                this.startDragEvent = function (evt) {
                    evt.preventDefault();
                    if (evt.srcElement != self.eleTitle) {
                        return;
                    }
                    self.isDragging = true;
                    //紀錄滑鼠按下的座標位置(畫面x,y)
                    self.tmpClientX = evt.clientX;
                    self.tmpClientY = evt.clientY;
                    Box.saveTmpLeftTop(self);
                };

                // mousemove event
                this.dragingEvent = function (evt) {
                    evt.preventDefault();
                    if (self.isDragging) {
                        // Calculate the new position of the box
                        var dx = evt.clientX - self.tmpClientX;
                        var dy = evt.clientY - self.tmpClientY;
                        // Update the position of the box
                        Box.updateLeftTop(self, dx, dy);
                        self.tmpClientX = evt.clientX;
                        self.tmpClientY = evt.clientY;
                        self.checkNearestBox(self, 100);
                    }
                }

                // mouseup event
                this.stopDragEvent = function (evt) {
                    evt.preventDefault();
                    if (self.isDragging) {
                        self.info(evt);
                        if (self.hasSwapBox()) {
                            self.checkSwapPos(self);
                        } else {
                            console.log("no swap,restore");
                            Box.loadTmpLeftTop(self);
                        }
                        delete self.tmpClientX;
                        delete self.tmpClientY;
                    }
                    self.isDragging = false;
                };
                this.getTitle().addEventListener("mousedown", this.startDragEvent);
                self.container.addEventListener("mousemove", this.dragingEvent);
                self.container.addEventListener("mouseup", this.stopDragEvent);
            }


            static calDxDy(box1, box2) {
                var x1 = Box.boxesInitPos[box1.getBox().id]['x'];
                var y1 = Box.boxesInitPos[box1.getBox().id]['y'];
                var x2 = Box.boxesInitPos[box2.getBox().id]['x'];
                var y2 = Box.boxesInitPos[box2.getBox().id]['y'];
                return { dx: x2 - x1, dy: y2 - y1 };
            }
            /*
            A , B 換位子
            A --> B (A移動到 B)
            找出 A,B 原來的offset x,y
            算出 


            */
            checkSwapPos(self) {
                var boxList = Box.getBoxes();
                for (var i in boxList) {
                    if (boxList[i].swapPos) {
                        boxList[i].swapPos = false;
                        var result = Box.calDxDy(self, boxList[i]);

                        self.setBoxLeftTop(result['dx'], result['dy']);
                        boxList[i].setBoxLeftTop(-result['dx'], -result['dy']);
                        console.log(self.eleBox.id, "-->", boxList[i].eleBox.id,
                            result['dx'], result['dy']);
                        console.log(boxList[i].eleBox.id, "-->", self.eleBox.id,
                            -result['dx'], -result['dy']);

                        boxList[i].eleTitle.style['border'] = '0px';
                        break;
                    }
                }
            }

            checkNearestBox(self, distance) {
                var boxList = Box.getBoxes();
                for (var i in boxList) {
                    var aBox = boxList[i];
                    if (aBox.eleBox == self.eleBox) {
                        continue;
                    }
                    var x1 = self.eleBox.offsetLeft;
                    var y1 = self.eleBox.offsetTop;
                    var x2 = aBox.eleBox.offsetLeft;
                    var y2 = aBox.eleBox.offsetTop;
                    var calDistance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                    if (calDistance <= distance) {
                        aBox.eleTitle.style['border'] = '1px solid #f47';
                        aBox.swapPos = true;
                    } else {
                        aBox.eleTitle.style['border'] = '0px';
                        aBox.swapPos = false;
                    }
                }
            }

            stopDrag() {
                var self = this;
                this.getTitle().style.display = "none";
                var boxList = Box.getBoxes();
                this.getTitle().removeEventListener("mousedown", this.startDragEvent);
                self.container.removeEventListener("mousemove", this.dragingEvent);
                self.container.removeEventListener("mouseup", this.stopDragEvent);
            }

            hasSwapBox() {
                var boxList = Box.getBoxes();
                for (var i in boxList) {
                    if (boxList[i].swapPos) {
                        return true;
                    }
                }
                return false;
            }

            info(evt) {
                //console.log(this.eleBox.id);
                //console.log(Box.boxesInitPos);
            }

            getTitle() {
                return this.eleTitle;
            }

            setBoxLeftTop(x, y) {
                this.getBox().style.left = x + 'px';
                this.getBox().style.top = y + 'px';
            }

            getBox() {
                return this.eleBox;
            }
        }

        Box.addBox(new Box('box1'));
        Box.addBox(new Box('box2'));
        Box.addBox(new Box('box3'));
        console.log("init...", Box.boxesInitPos);
        var boxes = Box.getBoxes();

        var startButton = document.getElementById("startButton");
        startButton.addEventListener("click", function () {
            for (var i in boxes) {
                Box.boxes[i].startDrag();
            }
        });
        var stopButton = document.getElementById("stopButton");
        stopButton.addEventListener("click", function () {
            for (var i in boxes) {
                boxes[i].stopDrag();
            }
        });

        for (var i in boxes) {
            Box.boxes[i].startDrag();
        }
    </script>


</body>

</html>