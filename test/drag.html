<!DOCTYPE html>
<html>

<head>
    <title>Draggable Divs</title>
    <style>
        .box {
            position: relative;
            width: 200px;
            height: 200px;
            background-color: #f0f0f0;
        }

        .title {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ccc;
            cursor: move;
            display: none;
            z-index: 2;
            opacity: 0.5;
        }

        #startButton,
        #stopButton {
            margin-top: 20px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <button id="startButton">Start</button>
    <button id="stopButton">Stop</button>
    <div>
        <div id="box1" class="box">
            <h1><span style='font-size:164px'>1</span></h1>
        </div>
        <div id="box2" class="box">
            <h1><span style='font-size:164px'>2</span></h1>
        </div>
    </div>
    <script>

        /**
         * 將想要可拖拉的div套上class="box"
         * 
         */
        class Box {
            // 所有可拖拉的盒子
            static boxes = [];
            static boxesInitPos = {};

            static addBox(box) {
                Box.boxes.push(box);
                Box.boxesInitPos[box.getBox().id] = {
                    "x": box.getBox().offsetLeft,
                    "y": box.getBox().offsetTop
                }
                window[box.getBox().id] = box;
            }

            static getBoxes() {
                return Box.boxes;
            }

            constructor(boxId) {
                this.swapPos = false;
                this.isDragging = false;
                this.eleTitle = document.createElement('div');
                this.eleTitle.classList.add("title");
                this.eleBox = document.getElementById(boxId);
                this.eleBox.appendChild(this.eleTitle);
                this.container = document.getElementsByTagName('body')[0];
                // 元素的座標資訊
                this.pos = {
                    // 元素擺放到畫面時的top,left預設為""
                    "top": 0, "left": 0,
                    // 元素擺放到畫面時的左上角 x,y 座標 (尚未拖拉前的位置)
                    "offsetLeft": this.eleBox.offsetLeft,
                    "offsetTop": this.eleBox.offsetTop
                };
                this.info();
            }

            startDrag() {
                var self = this;
                this.getTitle().style.display = "block";

                // mousedown event
                this.startDragEvent = function (evt) {
                    evt.preventDefault();
                    if (evt.srcElement != self.eleTitle) {
                        return;
                    }
                    self.isDragging = true;
                    //紀錄滑鼠按下的座標位置(畫面x,y)
                    self.pos['clientX'] = evt.clientX;
                    self.pos['clientY'] = evt.clientY;
                    self.pos['_top'] = self.pos['top'];
                    self.pos['_left'] = self.pos['left'];
                    self.info(evt);
                };

                // mousemove event
                this.dragingEvent = function (evt) {
                    if (self.isDragging) {
                        // Calculate the new position of the box
                        var dx = evt.clientX - self.pos['clientX'];
                        var dy = evt.clientY - self.pos['clientY'];
                        self.pos['top'] += dy;
                        self.pos['left'] += dx;
                        // Update the position of the box
                        self.setBoxLeftTop(self.pos['left'], self.pos['top']);
                        self.pos['clientX'] = evt.clientX;
                        self.pos['clientY'] = evt.clientY;
                        self.checkNearestBox(self, 100);
                    }
                }
                this.stopDragEvent = function (evt) {
                    evt.preventDefault();
                    if (self.isDragging) {
                        self.info(evt);
                        if (self.hasSwapBox()) {
                            self.checkSwapPos(self);
                        } else {
                            console.log("no swap,restore");
                            self.pos['top'] = self.pos['_top'];
                            self.pos['left'] = self.pos['_left'];
                            self.setBoxLeftTop(self.pos['left'], self.pos['top']);
                        }
                        delete self.pos['clientX'];
                        delete self.pos['clientY'];
                        delete self.pos['_left'];
                        delete self.pos['_top'];
                    }
                    self.isDragging = false;
                };
                this.getTitle().addEventListener("mousedown", this.startDragEvent);
                self.container.addEventListener("mousemove", this.dragingEvent);
                self.container.addEventListener("mouseup", this.stopDragEvent);
            }

            swapOffsetLeftTop(aBox, bBox) {
                var x = aBox.pos['offsetLeft'];
                var y = aBox.pos['offsetTop'];
                aBox.pos['offsetLeft'] = bBox.pos['offsetLeft'];
                aBox.pos['offsetTop'] = bBox.pos['offsetTop'];
                bBox.pos['offsetLeft'] = x;
                bBox.pos['offsetTop'] = y;
            }

            checkSwapPos(self) {
                var boxList = Box.getBoxes();
                for (var i in boxList) {
                    if (boxList[i].swapPos) {
                        boxList[i].swapPos = false;
                        var dx = self.pos['offsetLeft'] - boxList[i].pos['offsetLeft'];
                        var dy = self.pos['offsetTop'] - boxList[i].pos['offsetTop'];
                        //self.swapOffsetLeftTop(boxList[i],self);
                        self.pos['top'] = -dy;
                        self.pos['left'] = -dx;
                        boxList[i].pos['top'] = dy;
                        boxList[i].pos['left'] = dx;

                        self.setBoxLeftTop(-dx, -dy);
                        boxList[i].setBoxLeftTop(dx, dy);

                        boxList[i].eleTitle.style['border'] = '0px';
                        console.log("swap ", self.eleBox.id, boxList[i].eleBox.id);
                        break;
                    }
                }
            }

            checkNearestBox(self, distance) {
                var boxList = Box.getBoxes();
                for (var i in boxList) {
                    var aBox = boxList[i];
                    if (aBox.eleBox == self.eleBox) {
                        continue;
                    }
                    var x1 = self.eleBox.offsetLeft;
                    var y1 = self.eleBox.offsetTop;
                    var x2 = aBox.eleBox.offsetLeft;
                    var y2 = aBox.eleBox.offsetTop;
                    var calDistance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                    if (calDistance <= distance) {
                        aBox.eleTitle.style['border'] = '1px solid #f47';
                        aBox.swapPos = true;
                    } else {
                        aBox.eleTitle.style['border'] = '0px';
                        aBox.swapPos = false;
                    }
                }
            }

            stopDrag() {
                var self = this;
                this.getTitle().style.display = "none";
                var boxList = Box.getBoxes();
                this.getTitle().removeEventListener("mousedown", this.startDragEvent);
                self.container.removeEventListener("mousemove", this.dragingEvent);
                self.container.removeEventListener("mouseup", this.stopDragEvent);
            }

            hasSwapBox() {
                var boxList = Box.getBoxes();
                for (var i in boxList) {
                    if (boxList[i].swapPos) {
                        return true;
                    }
                }
                return false;
            }

            info(evt) {
                console.log(this.eleBox.id, this.pos);
                //console.log(Box.boxesInitPos);
            }

            getTitle() {
                return this.eleTitle;
            }

            setBoxLeftTop(x, y) {
                this.getBox().style.left = x + 'px';
                this.getBox().style.top = y + 'px';
            }

            getBox() {
                return this.eleBox;
            }
        }

        Box.addBox(new Box('box1'));
        Box.addBox(new Box('box2'));
        console.log("init...", Box.boxesInitPos);
        //Box.addBox(new Box('box3'));
        var boxes = Box.getBoxes();

        var startButton = document.getElementById("startButton");
        startButton.addEventListener("click", function () {
            for (var i in boxes) {
                Box.boxes[i].startDrag();
            }
        });
        var stopButton = document.getElementById("stopButton");
        stopButton.addEventListener("click", function () {
            for (var i in boxes) {
                boxes[i].stopDrag();
            }
        });

        for (var i in boxes) {
            Box.boxes[i].startDrag();
        }
    </script>


</body>

</html>